""" THIS FILE IS AUTOMATICALLY GENERATED BY THE DEPLOY SCRIPT """

 type SynthByCurrencyKey @entity {
  " currency key "
  id: ID!
  proxyAddress: Bytes!
}

type Synth @entity {
  " lowercase address of the proxy contract for the synth "
  id: ID!
  name: String!
  symbol: String!
  totalSupply: BigDecimal!
}

type SynthBalance @entity {
  " timestamp + account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: String!
  timestamp: BigInt!
  synth: Synth
}

" we dont query these entities but only use it to store aggregate data we need during syncing "
type LatestSynthBalance @entity {
  " account + synth address "
  id: ID!
  amount: BigDecimal!
  address: Bytes!
  account: String!
  timestamp: BigInt!
  synth: Synth
}

type DelegatedWallet @entity {
  " authoriser-delegate "
  id: ID!
  authoriser: Bytes!
  delegate: Bytes!
  canMint: Boolean
  canBurn: Boolean
  canClaim: Boolean
  canExchange: Boolean
}

type ExchangeEntrySettled @entity {
  " transaction hash and log index "
  id: ID!
  " synth exchanged from "
  from: Bytes!
  " synth exchanged to "
  src: Bytes!
  " number of units of synth from exchanged "
  amount: BigDecimal!
  " address which receives the settlement "
  dest: Bytes!
  " amount reclaimed of dest due to underpayment "
  reclaim: BigDecimal!
  " amount returned of dest due to overpayment "
  rebate: BigDecimal!
  " aggregator price round for src synth "
  srcRoundIdAtPeriodEnd: BigInt!
  " aggregator price round for dest synth "
  destRoundIdAtPeriodEnd: BigInt!
  " time when the original exchange occured "
  exchangeTimestamp: BigInt!
}

type ExchangeEntryAppended @entity {
  " transaction hash and log index "
  id: ID!
  " ethereum address which funded the exchange "
  account: Bytes!
  " synth exchanged from "
  src: Bytes!
  " number of units of synth from exchanged "
  amount: BigDecimal!
  " synth exchanged to "
  dest: Bytes!
  " number of units of synth to received "
  amountReceived: BigDecimal!
  " fee paid in sUSD to the synthetix fee pool "
  exchangeFeeRate: BigDecimal!
  " aggregator price round for src synth "
  roundIdForSrc: BigInt!
  " aggregator price round for dest synth "
  roundIdForDest: BigInt!
}

type TemporaryExchangePartnerTracker @entity {
  " Transaction hash of the Exchange event "
  id: ID!
  " Total transaction volume in USD across all ExchangeEntryAppended events in a single tx hash "
  usdVolume: BigDecimal
  " Total fees from this transaction hash "
  usdFees: BigDecimal
  " String format of the tracking code for a given partner "
  partner: String
}

type DailyExchangePartner @entity {
  " Day timestamp + tracking code of the partner "
  id: ID!
  " Total transaction volume in USD for the partner on this day "
  usdVolume: BigDecimal!
  " Total fees generated by the volume partner for this day "
  usdFees: BigDecimal!
  " Total number of trades from the volume partner for this day "
  trades: BigInt!
  " Tracking code of the partner "
  partner: String!
  " unix timestamp at the beginning of the day "
  timestamp: BigInt!
}

type ExchangePartner @entity {
  " Tracking code of the partner "
  id: ID!
  " Total transaction volume in USD for the partner "
  usdVolume: BigDecimal!
  " Total fees generated by the volume partner "
  usdFees: BigDecimal!
  " Total number of trades from the volume partner "
  trades: BigInt!
}

" we dont query this entity but only use it to store aggregate data we need during syncing "
type InversePricingInfo @entity {
  " Name of inverse synth. E.g. iETH "
  id: ID!
  " whether or not this inverse synth has been frozen "
  frozen: Boolean!
  " configured upper limit "
  upperLimit: BigDecimal!
  " configured lower limit "
  lowerLimit: BigDecimal!
  " matching price point with long synth "
  entryPoint: BigDecimal!
}

type LatestRate @entity {
  " Name of synth. E.g. sUSD "
  id: ID!
  " Synth USD rate "
  rate: BigDecimal!
  " Address of the aggregator which produces current result "
  aggregator: Bytes!
}

" Latest Rates over time "
type RateUpdate @entity {
  " <transaction hash>-<currency key> "
  id: ID!
  " currencyKey for which this this rate update applies "
  currencyKey: Bytes!
  " currencyKey expressed as a string "
  synth: String!
  " the rate recorded at this timestamp "
  rate: BigDecimal!
  " the block which this rate was recorded "
  block: BigInt!
  " timestamp of the block in which the rate was recorded "
  timestamp: BigInt!
}

" DEPRECATED: See the Candles entity"
type DailyCandle @entity {
  " DEPRECATED: See the Candles entity "
  id: ID!
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  timestamp: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type SynthExchange @entity {
  id: ID!
  account: Exchanger!
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  feesInUSD: BigDecimal!
  toAddress: Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
}

" Tracks this event from the Synthetix.sol contract. (Atomic exchanges also trigger standard SynthExchange events.)"
type AtomicSynthExchange @entity {
  id: ID!
  account: Exchanger!
  fromSynth: Synth
  toSynth: Synth
  fromAmount: BigDecimal!
  fromAmountInUSD: BigDecimal!
  toAmount: BigDecimal!
  toAmountInUSD: BigDecimal!
  feesInUSD: BigDecimal!
  toAddress: Bytes!
  timestamp: BigInt!
  gasPrice: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type ExchangeReclaim @entity {
  id: ID!
  account: Exchanger!
  currencyKey: Bytes!
  amount: BigDecimal!
  amountInUSD: BigDecimal!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Tracks this event from the Synthetix.sol contract "
type ExchangeRebate @entity {
  id: ID!
  account: Exchanger!
  currencyKey: Bytes!
  amount: BigDecimal!
  amountInUSD: BigDecimal!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

type Total @entity {
  " $timestamp-$bucketMagnitude-$synth-$period "
  id: ID!
  " timestamp of the beginning of the time period this represents "
  timestamp: BigInt!
  " which product the volume came from. Ex 'futures' or 'exchange' "
  product: String
  " number of seconds the data covers after `timestamp` "
  period: BigInt!
  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!
  " synth to filter by "
  synth: Synth
  " number of trades completed over period "
  trades: BigInt!
  " number of unique traders who were first seen in this period "
  newExchangers: BigInt!
  " number of unique traders seen over period "
  exchangers: BigInt!
  " synth value exchanged in USD units "
  exchangeUSDTally: BigDecimal!
  " synth value received in fees in USD units "
  totalFeesGeneratedInUSD: BigDecimal!
}

" An individual Exchanger aggregated by various time groupings "
type Exchanger @entity {
  " hex address in lowercase (and for non global: hex address in lowercase-$timestamp-$period-$bucketMagnitude-$synth "
  id: ID!
  " timestamp of the beginning of the time period this represents, or 0 for no period filter "
  timestamp: BigInt!
  " number of seconds the data covers after `timestamp`, or 0 for no period filter "
  period: BigInt!
  " minimum power of 10 (in from USD value) the trade must be. ex, 2 means $100 or higher) "
  bucketMagnitude: BigInt!
  " synth to filter by "
  synth: Synth
  " when the user first exchanged "
  firstSeen: BigInt!
  " when the user last exchanged "
  lastSeen: BigInt!
  " nubmer of trades by account "
  trades: BigInt!
  " synth value exchanged in USD units by account "
  exchangeUSDTally: BigDecimal!
  " synth value received in fees in USD units from account "
  totalFeesGeneratedInUSD: BigDecimal!
  " balances "
  balances: [LatestSynthBalance!]!
  " exchanges "
  exchanges: [SynthExchange!]! @derivedFrom(field: "account")
}

type ExchangeFee @entity {
  " Name of the synth. E.g. sUSD "
  id: ID!
  " Current Fee as a ratio of the trade amount "
  fee: BigDecimal!
}

type Candle @entity {
  " synth-period-periodId (periodId is timestamp / period) "
  id: ID!
  " Ticker for synth (e.g. 'sUSD') or 'SNX'"
  synth: String!
  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!
  average: BigDecimal!
  timestamp: BigInt!
  " Duration this candle captures in seconds. Year, quarter, month, week, day, hour, and 15 minutes available. "
  period: BigInt!
  " Number of RateUpdates aggregated into this candle, mostly useful for the indexer to calculate averages "
  aggregatedPrices: BigInt!
}

type FuturesMarket @entity {
  " Address of the market "
  id: ID!
}

" Synthentix is an aggregation entity "
type Synthetix @entity {
  id: ID!
  " number of stakers currently staking "
  issuers: BigInt!
  " number of addresses which hold SNX "
  snxHolders: BigInt!
}

" An individual Issuer "
type Issuer @entity {
  id: ID!
}

" An individual SNX holder (always overridden with their latest information) "
type SNXHolder @entity {
  " address of holder "
  id: ID!
  " last block where an event happened "
  block: BigInt!
  " last time where an event happened "
  timestamp: BigInt!
  " current SNX balance of the holder "
  balanceOf: BigDecimal
  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal
  " SNX which can be spent as of last event "
  transferable: BigDecimal
  initialDebtOwnership: BigInt
  debtEntryAtIndex: BigInt
  " number of claims performed "
  claims: BigInt
  " number of mints performed "
  mints: BigInt
}

" A historical debt tracker "
type DebtSnapshot @entity {
  id: ID!
  " last block where an event happened "
  block: BigInt!
  " last time when an event happened "
  timestamp: BigInt!
  " address for which these statistics are applicable "
  account: Bytes!
  balanceOf: BigDecimal
  " SNX which is being used for collateral as of last event and cannot be spent "
  collateral: BigDecimal
  " sUSD of debt as of last event "
  debtBalanceOf: BigDecimal
  " sUSD debt portion a user had at last index "
  initialDebtOwnership: BigDecimal
  " debt entry when `initialDebtOwnership` applies"
  debtEntryAtIndex: BigInt
}

type DailyIssued @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!
  " amount issued "
  value: BigDecimal!
  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

type DailyBurned @entity {
  " unix timestamp at beginning of day of the measurement "
  id: ID!
  " amount burned "
  value: BigDecimal!
  " amount of debt as of the last event for this day "
  totalDebt: BigDecimal!
}

" Tracks this event from various Synth.sol instances "
type Issued @entity {
  id: ID!
  account: Bytes!
  value: BigDecimal!
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

" Burned tracks this event from various Synth.sol instances "
type Burned @entity {
  id: ID!
  account: Bytes!
  value: BigDecimal!
  source: String!
  timestamp: BigInt!
  gasPrice: BigInt!
  block: BigInt!
}

type RewardEscrowHolder @entity {
  " address which holds a rewardescrow "
  id: ID!
  " amount of tokens remaining to be claimed from the escrow "
  balanceOf: BigDecimal!
  " amount of SNX claimed from the escrow "
  vestedBalanceOf: BigDecimal!
}

" Tracks this event from Synthetix.sol "
type FeesClaimed @entity {
  id: ID!
  account: Bytes!
  value: BigDecimal!
  rewards: BigDecimal!
  block: BigInt!
  timestamp: BigInt!
}

type FeePeriod @entity {
  id: ID!
  startTime: BigInt!
  feesToDistribute: BigDecimal!
  feesClaimed: BigDecimal!
  rewardsToDistribute: BigDecimal!
  rewardsClaimed: BigDecimal!
}

type TotalActiveStaker @entity {
  " single value "
  id: ID!
  " number of stakers seen "
  count: BigInt!
}

type TotalDailyActiveStaker @entity {
  " unix timestamp at beginning of day relevant to this statistic "
  id: ID!
  " unix timestamp as a BigInt (so it can be filtered) "
  timestamp: BigInt!
  " number of stakers seen on this day "
  count: BigInt!
}

type ActiveStaker @entity {
  id: ID!
}

type FeeRate @entity {
  " string representing the setting name "
  id: ID!
  setting: String!
  " name of the synth this record applies to, if any "
  synth: String
  " value of the setting "
  rate: BigDecimal!
}

type AccountFlaggedForLiquidation @entity {
  " the deadline plus the staker address "
  id: ID!
  " the address of the staker "
  account: Bytes!
  " liqudation deadline "
  deadline: BigInt!
  " current collateral ratio "
  collateralRatio: BigInt!
  " snx that is liquidatable "
  liquidatableNonEscrowSNX: BigDecimal!
  " total collateral held by the staker including escrow amount "
  collateral: BigDecimal!
}

type AccountRemovedFromLiquidation @entity {
  " the time at which the staker fixed their c-ratio plus the staker address "
  id: ID!
  " the address of the staker "
  account: Bytes!
  " the time at which the staker fixed their c-ratio "
  time: BigInt!
}

type AccountLiquidated @entity {
  id: ID!
  "the liquidated address"
  account: Bytes!
  "the amount of SNX redeemed by the liquidator"
  snxRedeemed: BigDecimal!
  "the amount of sUSD liquidated"
  amountLiquidated: BigDecimal!
  "the address liquidating the account"
  liquidator: Bytes!
  "the time at which the liquidation occurred"
  time: BigInt!
}

type Loan @entity {
  " the loan id "
  id: ID!
  " the transaction hash of the loan "
  txHash: String!
  " the account receiving the loan "
  account: Bytes!
  " the currency of loan amount "
  currency: String!
  " the currency of the collateralAmount "
  collateralMinted: String!
  " the amount of the loan "
  amount: BigDecimal!
  " the amount of collateral "
  collateralAmount: BigDecimal!
  " is the loan still open? "
  isOpen: Boolean!
  " the timestamp the loan was created "
  createdAt: BigInt!
  " the timestamp the loan was closed "
  closedAt: BigInt
  " whether the loan has any partial liquidations "
  hasPartialLiquidations: Boolean!
}

type LoanLiquidated @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the loan id "
  loanId: BigInt!
  " the account that created the loan "
  account: Bytes!
  " the account that liquidated the loan "
  liquidator: Bytes!
  " the timestamp the loan was liquidated "
  timestamp: BigInt!
}

type LoanPartiallyLiquidated @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the loan id "
  loanId: BigInt!
  " the account that created the loan "
  account: Bytes!
  " the account that partially liquidated the loan "
  liquidator: Bytes!
  " the amount partially liquidated "
  liquidatedAmount: BigDecimal!
  " the amount partially liquidated plus the liquidation fee "
  liquidatedCollateral: BigDecimal!
  " the timestamp the loan was partially liquidated "
  timestamp: BigInt!
}

type CollateralDeposited @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the amount of collateral deposited "
  collateralAmount: BigDecimal!
  " the total amount of collateral after the deposit is included "
  collateralAfter: BigDecimal!
  " the account that created the loan "
  account: Bytes!
  " the loan id "
  loanId: BigInt!
  " the timestamp collateral was deposited "
  timestamp: BigInt!
}

type CollateralWithdrawn @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the amount of collateral withdrawn "
  amountWithdrawn: BigDecimal!
  " the total amount of collateral after the withdrawal is accounted for "
  collateralAfter: BigDecimal!
  " the account that created the loan "
  account: Bytes!
  " the loan id "
  loanId: BigInt!
  " the timestamp collateral was withdrawn "
  timestamp: BigInt!
}

type LoanRepaid @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the amount of the loan that was repaid "
  repaidAmount: BigDecimal!
  " the total amount of the loan after the repaid amount is accounted for "
  newLoanAmount: BigDecimal!
  " the account that created the loan "
  account: Bytes!
  " the loan id "
  loanId: BigInt!
  " the timestamp the loan was partially or fully repaid "
  timestamp: BigInt!
}

type DebtState @entity {
  " Global historical debt entry index "
  id: ID!
  period: BigInt!
  " time at which these values are recorded "
  timestamp: BigInt!
  " representation of total amount of debt issued over time. increases or decreases proportionally whenever synths are minted/burned "
  debtEntry: BigDecimal!
  " current value of all issued synths which this debt pool is responsible for. fluctuates based on the synth breakdown of the system * exchange rates "
  totalIssuedSynths: BigDecimal!
  " totalIssuedSynths / debtEntry - useful for tracking debt over time "
  debtRatio: BigDecimal!
}

type SystemSetting @entity {
  id: ID!
  " time at which these values are recorded "
  timestamp: BigInt!
  " SIP-37 Fee Reclamation: The number of seconds after an exchange is executed that must be waited before settlement. "
  waitingPeriodSecs: BigInt!
  " SIP-65 Decentralized Circuit Breaker: The factor amount expressed in decimal format E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below "
  priceDeviationThresholdFactor: BigDecimal!
  " The raio of collateral Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18) "
  issuanceRatio: BigDecimal!
  " How long a fee period lasts at a minimum. It is required for anyone to roll over the periods, so they are not guaranteed to roll over at exactly this duration, but the contract enforces that they cannot roll over any quicker than this duration. "
  feePeriodDuration: BigInt!
  " Users are unable to claim fees if their collateralisation ratio drifts out of target threshold "
  targetThreshold: BigDecimal!
  " SIP-15 Liquidations: liquidation time delay after address flagged (seconds) "
  liquidationDelay: BigInt!
  " SIP-15 Liquidations: issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio when flag means 1/0.5 = 200% cratio "
  liquidationRatio: BigDecimal!
  " SIP-15 Liquidations: penalty taken away from target of liquidation (with 18 decimals). E.g. 10% is 0.1e18 "
  liquidationPenalty: BigDecimal!
  " How long will the ExchangeRates contract assume the rate of any asset is correct "
  rateStalePeriod: BigInt!
  minimumStakeTime: BigInt!
  debtSnapshotStaleTime: BigInt!
  aggregatorWarningFlags: String!
  " SIP 112: ETH Wrappr: The maximum amount of ETH held by the EtherWrapper. "
  etherWrapperMaxETH: BigDecimal!
  " SIP 112: ETH Wrappr: The fee for depositing ETH into the EtherWrapper. "
  etherWrapperMintFeeRate: BigDecimal!
  " SIP 112: ETH Wrappr: The fee for burning sETH and releasing ETH from the EtherWrapper. "
  etherWrapperBurnFeeRate: BigDecimal!
  " SIP-120 Atomic exchanges: max allowed volume per block for atomic exchanges "
  atomicMaxVolumePerBlock: BigInt!
  " SIP-120 Atomic exchanges: time window (in seconds) for TWAP prices when considered for atomic exchanges "
  atomicTwapWindow: BigInt!
}

type Short @entity {
  " the short id "
  id: ID!
  " contract level info for the short position "
  contractData: ShortContract!
  " the transaction hash of the short "
  txHash: String!
  " the account that created the short "
  account: Bytes!
  " the type of collateral locked - sUSD, ETH, renBTC "
  collateralLocked: Bytes!
  " the amount of collateral locked in the short "
  collateralLockedAmount: BigDecimal!
  " the denomination of the loan repayment - sETH, sBTC "
  synthBorrowed: Bytes!
  " the amount owed denominated in the loan repayment synth "
  synthBorrowedAmount: BigDecimal!
  " the timestamp the accrued interest was most recently updated "
  accruedInterestLastUpdateTimestamp: BigInt!
  " is the short still open? "
  isOpen: Boolean!
  " the block the short was created at "
  createdAtBlock: BigInt!
  " the timestamp the short was created "
  createdAt: BigInt!
  " the timestamp the short was closed "
  closedAt: BigInt
  " liquidations that have been made on the short "
  liquidations: [ShortLiquidation!] @derivedFrom(field: "short")
  " collateral deposits and withdrawals that have been made on the short "
  collateralChanges: [ShortCollateralChange!] @derivedFrom(field: "short")
  " loan changes that have been made on the short - increasing or decreasing the short position "
  loanChanges: [ShortLoanChange!]! @derivedFrom(field: "short")
}

type ShortCollateralChange @entity {
  " the event tx hash plus event log index "
  id: ID!
  " denotes if the event was a deposit (true) or withdrawal (false)"
  isDeposit: Boolean!
  " the amount of collateral deposited or withdrawn "
  amount: BigDecimal!
  " the total amount of collateral after the deposit or withdrawal is included "
  collateralAfter: BigDecimal!
  " the respective short "
  short: Short!
  " the timestamp collateral was deposited or withdrawn "
  timestamp: BigInt!
  " the block the collateral was changed "
  blockNumber: BigInt!
}

type ShortLoanChange @entity {
  " the event tx hash plus event log index "
  id: ID!
  " denotes if the event was a repayment (true) or an increase of the loan (false)"
  isRepayment: Boolean!
  " the amount of loan repaid or increased "
  amount: BigDecimal!
  " the total amount of loan due after the repayment or increase is included "
  loanAfter: BigDecimal!
  " the respective short "
  short: Short!
  " the price of the repaid synth in dollars "
  rate: BigDecimal!
  " the timestamp of the loan repayment or increase "
  timestamp: BigInt!
  " the block the short loan was changed "
  blockNumber: BigInt!
}

type ShortLiquidation @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the account that liquidated the loan "
  liquidator: Bytes!
  " determines if the "
  isClosed: Boolean!
  " the amount of the loan that was burned "
  liquidatedAmount: BigDecimal!
  " the amount of the collateral that was taken away from the short owner "
  liquidatedCollateral: BigDecimal!
  " the respective short "
  short: Short!
  " the timestamp of the loan liquidation event "
  timestamp: BigInt!
  " the block of the liquidation event "
  blockNumber: BigInt!
}

type ShortContract @entity {
  " the address of the shorting contract "
  id: ID!
  " a list of shorts attached to each contract "
  shorts: [Short!] @derivedFrom(field: "contractData")
  " a list of changes to contract level data "
  contractUpdates: [ShortContractUpdate!] @derivedFrom(field: "contractData")
  " the min c-ratio for borrowers below which they can be liquidated "
  minCratio: BigInt!
  " the minimum collateral required to open a position "
  minCollateral: BigDecimal!
  " the fee for issuing a short "
  issueFeeRate: BigDecimal!
  " the max number of loans per account "
  maxLoansPerAccount: BigInt!
  " Time in seconds that a user must wait between interacting with a loan. Provides front running and flash loan protection. "
  interactionDelay: BigInt!
  " the manager is a contract that ties the shorting contract in with the rest of the Synthetix protocol "
  manager: Bytes!
  " a boolean that prevents new loans on the contract when false "
  canOpenLoans: Boolean!
}

type ShortContractUpdate @entity {
  " the event tx hash plus event log index "
  id: ID!
  " the field that was changed "
  field: String!
  " the new value of the field in string format "
  value: String!
  " the respective short contract "
  contractData: ShortContract!
  " the timestamp of the contract update event "
  timestamp: BigInt!
  " the block the short contract was udpated at "
  blockNumber: BigInt!
}

type Wrapper @entity {
  " wrapper address "
  id: ID!
  " address of wrapped token, empty if ETH"
  tokenAddress: String!
  " the current amount of synths minted by this wrapper"
  amount: BigDecimal!
  " the current amount of synths minted by this wrapper in USD"
  amountInUSD: BigDecimal!
  " the maximum amount of synths that can be minted by this wrapper"
  maxAmount: BigDecimal!
  " the currency key of this wrapper "
  currencyKey: String!
  " the total amount of fees generated by this wrapper "
  totalFees: BigDecimal!
  " the total amount of fees generated by this wrapper in USD"
  totalFeesInUSD: BigDecimal!
}

type WrapperMint @entity {
  " the transaction hash with a log index appended "
  id: ID!
  " address of the user minting "
  account: String!
  " amount of synth minted "
  principal: BigDecimal!
  " amount of fees collected "
  fee: BigDecimal!
  " total amount added to the wrapper "
  amountIn: BigDecimal!
  " the timestamp of the block that includes this event "
  timestamp: BigInt!
  " the address of the wrapper that minted this synth "
  wrapperAddress: String!
}

type WrapperBurn @entity {
  " the transaction hash with a log index appended "
  id: ID!
  " address of the user burning "
  account: String!
  " amount of synth burned "
  principal: BigDecimal!
  " amount of fees collected "
  fee: BigDecimal!
  " total amount removed from the wrapper "
  amountOut: BigDecimal!
  " the timestamp of the block that includes this event "
  timestamp: BigInt!
  " the address of the wrapper that burned this synth "
  wrapperAddress: String!
}